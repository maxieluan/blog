---
title: "Javascript颜文字混淆"
date: 2023-08-04T04:48:44+08:00
draft: false
tags: ["javascript", "混淆", "颜文字"]
categories: ["代码混淆"]
description: "这篇博客用于解释一种使用颜文字对代码进行混淆的方法"
author: "Max"
keywords: ["javascript", "混淆", "颜文字"]
featured: 
  flag: true
  weight: 1
---
## Introduction
最近在网上遇到了一段看似全是颜文字的代码，但是如果你把他们放到浏览器的控制台里面运行，会发现他们输出了`hello world`，而且代码里面没有任何关于`console`，`log`，甚至`hello world`的字样，这让我很好奇，于是我开始了一番调查，本片博客就是我对这段代码的解释。

代码如下：
```javascript
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ ['_']; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+/*´∇｀*/(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+(o^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((o^_^o) +(o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((o^_^o) +(o^_^o))+(o^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+((o^_^o) +(o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+(c^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(c^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+(c^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((o^_^o) +(o^_^o))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((o^_^o) +(o^_^o))+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');
```
## 方法
研究这个的方法并非看起来的那么困难。只需将代码粘贴到Visual Studio Code中并执行“代码格式化”，我们就可以看到其格式化版本如下：

```javascript
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻ / ["_"];
o = ﾟｰﾟ = _ = 3;
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ;
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o);
ﾟДﾟ = {
  ﾟΘﾟ: "_",
  ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
  ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
  ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
};
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o];
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ];
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ];
ﾟoﾟ =
  ﾟДﾟ["c"] +
  ﾟДﾟ["o"] +
  (ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
  ((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
  (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
  ((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
  ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
  ﾟДﾟ["c"] +
  (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
  ﾟДﾟ["o"] +
  ((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ];
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ];
ﾟεﾟ =
  ((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
  ﾟДﾟ.ﾟДﾟﾉ +
  (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
  ((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
  ((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
  (ﾟωﾟﾉ + "_")[ﾟΘﾟ];
ﾟｰﾟ += ﾟΘﾟ;
ﾟДﾟ[ﾟεﾟ] = "\\";
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)];
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o];
ﾟДﾟ[ﾟoﾟ] = '"';
ﾟДﾟ["_"](
  ﾟДﾟ["_"](
    ﾟεﾟ +
      ﾟДﾟ[ﾟoﾟ] +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ﾟｰﾟ +
      (o ^ _ ^ o) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      (ﾟｰﾟ + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ((o ^ _ ^ o) + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ((o ^ _ ^ o) + (o ^ _ ^ o)) +
      (o ^ _ ^ o) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      (ﾟｰﾟ + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟｰﾟ +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ﾟｰﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟДﾟ[ﾟεﾟ] +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ((o ^ _ ^ o) + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟｰﾟ +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      (ﾟｰﾟ + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ﾟｰﾟ +
      (ﾟｰﾟ + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      (ﾟｰﾟ + ﾟΘﾟ) +
      (c ^ _ ^ o) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟｰﾟ +
      ((o ^ _ ^ o) - ﾟΘﾟ) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      (c ^ _ ^ o) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ﾟｰﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟｰﾟ +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟｰﾟ +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      (ﾟｰﾟ + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟｰﾟ +
      (c ^ _ ^ o) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ((o ^ _ ^ o) + (o ^ _ ^ o)) +
      (ﾟｰﾟ + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      (ﾟｰﾟ + (o ^ _ ^ o)) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ((o ^ _ ^ o) + (o ^ _ ^ o)) +
      ((o ^ _ ^ o) - ﾟΘﾟ) +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟｰﾟ +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟΘﾟ +
      ﾟｰﾟ +
      ﾟｰﾟ +
      ﾟДﾟ[ﾟεﾟ] +
      ﾟｰﾟ +
      ((o ^ _ ^ o) - ﾟΘﾟ) +
      ﾟДﾟ[ﾟεﾟ] +
      (ﾟｰﾟ + ﾟΘﾟ) +
      ﾟΘﾟ +
      ﾟДﾟ[ﾟoﾟ]
  )(ﾟΘﾟ)
)("_");
```
为了进一步剖析这段代码，设置调试器并逐行检查它将是一种有价值的方法。这种方法将使我们更清楚地了解它的工作原理，并揭示任何隐藏的复杂性。

毫无疑问，这段代码最关键的部分在于最后一行。让我们把注意力集中在这个关键组件上，以解开代码的真正目的。

```js
Дﾟ["_"](
  ﾟДﾟ["_"](
    ...
  )(ﾟΘﾟ)
)("_");
```
直接跳到 spoiler，这一行相当于

```js
func = new Function(FunctionString);
outerFunc = new Function(func(1));
outerFunc("_")
```
这段胡言乱语背后的秘密是，它代表了字符串return `console.log(\\"hello world\\")`的Unicode。

所有前面的行都在构建三个基本元素中发挥作用：

1. 一个字符串`return`
2. 一个变量持有`[Function:Function]`构造函数
3. 存储从0到9的数字的变量。

令人惊讶的是，只要这些元素到位，你就可以执行任意代码。

## 一些技巧
### 如何构建数字：
看一下这行代码：
```js
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o);
```
这一行的目的是将变量ﾟДﾟ和ﾟΘﾟ都分配给值1。

类似的，其他变量也存在于数字4和3之类的数字中。通过利用这些变量，你可以轻松地构建任何你想要的数字。

### 如何拼接字符串：
在代码中，你可能会注意到使用了字面字符串，比如`constructor`和`return`。

尽管可以用Unicode表示法来构建字符串，但这个挑战的作者采用了另一种方法。

看一下这行代码：

```js
((ﾟωﾟﾉ == 3) + "_")
```
变量ﾟωﾟﾉ没有初始化，因此将执行为undefined。

现在，当代码检查表达式undefined == 3时，结果为false，导致与“_”连接后的文字字符串“false_”。

作者随后从字符串“false_”中提取字符s。

通过类似的方法，作者可以从true_中提取t和r，从undefined_中提取n，等等。

### 理解 `[Function:Function]`:
`[Function:Function]`在代码的功能中起着重要的作用。让我们看看它是如何获得的。

#### `[Function:Function]` 是一个constructor function:
`[Function:Function]` 是一个constructor function，如果你执行它，他将等同于执行`new Function(arg)`。这允许代码根据函数字符串arg动态地创建和执行函数。

#### 构建 `[Function:Function]`:
正如前面提到的，代码构建了字符串`constructor`。

```js
(o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
```
这里，`(o ^ _ ^ o)`是3，`ﾟoﾟ`是`"constructor"`。

3是一个数字，但也是一个对象。它有一个叫做`constructor`的属性，是一个函数。它是一个构造数字的函数，类型为`[Function:Number]`。

这个函数也有一个叫做`constructor`的属性，是一个构造函数的函数，类型为`[Function:Function]`。

因此，`(o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]`等同于`[Function:Function]`。

## 结论
这个代码提出的挑战很有趣。虽然它本身可能并不难，但它的创造力却很突出。理解这种技术可以更深入地了解JavaScript的内部工作原理，让开发人员扩展对语言的理解。

然而，理解不应该标志着旅程的终点。一个项目可以涉及编写一个程序，使用类似的技术来混淆代码。这是我计划在未来探索的一个前景。

但是，需要认识到的是，虽然这种方法很有创意，但它并不是很实用，甚至可能被认为是有风险的。在生产代码中实现它是不可取的，因为它可能会带来潜在的复杂性和潜在的安全风险。最好保留在实验或教育目的中，其中的重点在于揭示JavaScript的复杂性，而不是实际应用。

总结一下，这段代码提供了一个迷人的一瞥，展示了JavaScript的能力，激发了好奇心和创造力，但是在考虑它的现实应用时必须谨慎。
